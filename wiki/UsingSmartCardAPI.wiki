#summary Writing Android applications with access to Secure Elements using the SmartCard API


=Introduction=

This document explains how the !SmartCard API for can be used to
develop and test Android applications which communicate with Secure Elements available in the real device or the emulator.

=====Notice=====
Currently, real devices do not support UICC access as the corresponding changes in the baseband are not implemented yet thus SIM access can only be tested with the Android emulator. See [UICCSupport] for more information.<br/>

===Prerequisites===
  * The development phone is flashed with !SmartCard API support according to [BuildingTheSystem] and the integration is verified according to [IntegrationsTests]
  * Basic knowledge of [http://www.oracle.com/technetwork/java/javacard/overview/index.html Java Card] applets and [http://www.wrankl.de/SCH/SCH.html smart card] communication
  * Eclipse development IDE with the Android Development Tools (ADT) and Java installed on the host (although Eclipse is not mandatory). See http://developer.android.com/sdk/eclipse-adt.html
  * Android SDK with !SmartCard API integrated according to [BuildingTheSystem] used in Eclipse
  * Basic understanding of the Android development platform. See http://developer.android.com/sdk/index.html<br/>

===Setting up the Environment===
Since the !SmartCard API is part of the Android platform, the Eclipse development environment needs to be configured in order to use the compiled SDK (from [BuildingTheSystem]) with the integrated !SmartCard API interface instead of the official SDK from Google.<br/>
If not yet done, adapt the SDK location in Eclipse in order to register the API extension available in the development environment.<br/>
The output of _make PRODUCT-sdk-sdk_ can be found under _$ANDROID_ROOT/out/host/linux-x86/sdk/..._
 * Open Eclipse and go to Windows -> Preferences -> Android
 * Specify the SDK Location as _$ANDROID_ROOT/out/host/linux-x86/sdk/..._
<br/>

=Hello, Smart Card.=
For developers, the most important code to get started with in a new development environment is the _Hello, World._ sample. The text to be displayed will be created from the applet installed on the Secure Element.<br/>
The Android application communicates with the applet running on the Secure Element and displays the text response of the card APDU command on the screen of the device.<br/>
This tutorial assumes that the Eclipse environment is set up properly and that the ADT plug in is installed according to the Android developer documentation on the Internet.<br/>
The _Hello Smartcard_ Java Card applet available in the SVN repository needs to be installed on the Secure Element with any kind of card management tool like JLoad from the _Mobile Security Developers Kit_.
  * Using the Eclipse project wizard, create a new Android project
    _File -> New -> Project_
  * Select _Android Project_ and click _Next_
  * To create the project, fill in the required fields
    Project name: _!HelloSmartcard_<br/>
    Application name: _Hello Smartcard_<br/>
    Package name: _com.gieseckedevrient.android.hellosmartcard_<br/>
    Create Activity: _!MainActivity_
  * Click _Finish_ to create the body of the (empty) Android application<br/>

===Creating the View===
In this tutorial, we do not care much about the user interface, we just create a button which starts the communication with the applet on the smart card when pressed.<br/>
In _!MainActivity.java_, add the following code to the _onCreate()_ method.
{{{
@Override
public void onCreate(Bundle savedInstanceState) {
  final String LOG_TAG = "HelloSmartcard";

  super.onCreate(savedInstanceState);

  LinearLayout layout = new LinearLayout(this);
  layout.setLayoutParams(new LayoutParams(
          LayoutParams.WRAP_CONTENT,
          LayoutParams.WRAP_CONTENT));

  Button button = new Button(this);
  button.setLayoutParams(new LayoutParams(
          LayoutParams.WRAP_CONTENT,
          LayoutParams.WRAP_CONTENT));

  button.setText("Click Me");
  button.setOnClickListener(new OnClickListener() {
    public void onClick(View v) {
      // TODO: smart card access
    }
  });

  layout.addView(button);
  setContentView(layout);
}
}}}
Add the required imports for the new code manually or use `Ctrl+Shift+O` within Eclipse to organize all imports.<br/>

===Initialize the !SmartCard API===
Create a handle to the !SmartCard API. At the end of the _onCreate()_ method, add
{{{
try {
  smartcard = new SmartcardClient(this, null);
} catch (SecurityException e) {
  Log.e(LOG_TAG, "Binding not allowed, SMARTCARD permission?");
} catch (Exception e) {
  Log.e(LOG_TAG, "Exception: " + e.getMessage());
}
}}}
and create a _!SmartcardClient_ object within the _!MainActivity_ class
{{{
SmartcardClient smartcard;
}}}
If the sample is executed on the phone now, a security exception is thrown complaining about a missing _SMARTCARD_ permission. See the log output of the command when starting the application in its current stage
{{{
$ adb logcat *:v
}}}
In order to be allowed to use the !SmartCard API, an application must implement the _SMARTCARD_ permission. This permission notifies a user when installing an application that requests access to a Secure Element.<br/><br/>
Define the permission in the _!AndroidManifest.xml_ file
{{{
<uses-permission android:name="android.permission.SMARTCARD"/>
}}}
and the sample will launch properly.<br/><br/>
Note that the constructor of _!SmartcardClient_ will automatically bind to the !SmartcardService interface in the background. Since service binding is asynchronous in Android, the proper way to initialize the library is to wait for a notification event as discussed later.<br/><br/>
To clean up the service binding, call the shutdown method when the application is closing or is not using smart card services anymore (for example, in _onDestroy()_)
{{{
@Override
protected void onDestroy() {
  if (smartcard != null) {
    smartcard.shutdown();
  }

  super.onDestroy();
}
}}}

===Accessing the Smart Card===
Add the following code snippet inside the _onClick()_ handler of the button
{{{
ICardChannel cardChannel;
try {
  cardChannel = smartcard.openLogicalChannel(
      "Mobile Security Card",
      new byte[] { (byte)0xD2, 0x76, 0x00, 0x01, 0x18, 0x00, 0x02,
                   (byte)0xFF, 0x49, 0x50, 0x25, (byte)0x89,
                   (byte)0xC0, 0x01, (byte)0x9B, 0x01});

  byte[] respApdu = cardChannel.transmit(
           new byte[] {(byte)0x90, 0x10, 0x00, 0x00, 0x00 });

  cardChannel.close();

  byte[] helloStr = new byte[respApdu.length - 2];
  System.arraycopy(respApdu, 0, helloStr, 0, respApdu.length - 2);

  Toast.makeText(MainActivity.this, new String(helloStr),
                 Toast.LENGTH_LONG).show();
} catch (CardException e) {
  return;
}
}}}
In this code, a logical channel to the _!HelloSmartcard_ applet identified by its AID `D2 76 00 01 18 00 02 FF 49 50 25 89 C0 01 9B 01` is created. The _!HelloSmartcard_ applet
specific APDU command `90 10 00 00 00` is sent to retrieve the applet response.<br/>
The last two bytes of the response (=status word or SW1SW2), typically `90 00` on successful execution of the command are truncated and the result is displayed on the screen.<br/>

===Running the Application===
In Eclipse, click on Run or press `Ctrl+F11` to execute the sample on the phone.<br/>
Each time the applet is accessed, the counter is incremented by one and stored in NV memory on the Secure Element. This shows the data persistence of the application running on the smart card.<br/>
To debug the application, you need to
 * Add additional `Log.e()` messages
 * Run `$ logcat *:v` in a terminal to show all log messages
 * Use Eclipse to set breakpoints and step through the code


<br><br>
=Integration of the shared library based !SmartCard API.=

Download the `smartcard-api_sharedlibrary-2_2_1.tgz` patch and extract the content. The package includes: 

 * The shared library based !SmartCard API as patch for the android source tree (`smartcard-api-2.2.1.patch`)
 * The CTS extension for the shared library based !SmartCard API as patch for the android source tree (`cts.patch`)
 * The emulator extention for the !SmartCard API as patch for the android source tree (`emulator.patch`)
 * The system modifications/extension for the UICC connection for the !SmartCard API as patch for the android source tree (`uicc.patch`)

Apply the patches:
{{{
$ cd <ANDROID_ROOT_DIR> 
$ patch -p1 < <path_to_my_patches>/smartcard-api-2_2_1/smartcard-api-2.2.1.patch 
$ patch -p1 < <path_to_my_patches>/smartcard-api-2_2_1/uicc.patch 
$ patch -p1 < <path_to_my_patches>/smartcard-api-2_2_1/emulator.patch 
$ patch -p1 < <path_to_my_patches>/smartcard-api-2_2_1/cts.patch  
}}}

After applying the patches the android source tree contains all !SmartCard API source files in "/packages/apps/!SmartcardService": 
 * !SmartcardService/ - Contains the whole !SmartCard API project
 * jni/ Contains the native sources of this project
 * src/ - Contains the source files of the !SmartCard API Service (backend system of the !SmartCard API)
 * openmobileapi/ - Contains the Open Mobile API (SIMalliance standardized API for applications) shared library project. 
 * smartcardapi/  - Contains the !SmartcardClient API (proprietary API for applications) shared library project. 
 <br>

For integrating the !SmartCard API into the product build the variable PRODUCT_PACKAGES (e.g. in core.mk or device.mk) has to be extended with following lines:
{{{
PRODUCT_PACKAGES := \ 
 org.simalliance.openmobileapi \  (for integrating the SmartCard API with the shared library for SIMalliance standardized API Open Mobile API)
 android.smartcard \  (for integrating the SmartCard API with the shared library for the proprietary API SmartcardClient) 		
}}}
 
Note: The `smartcard-api-2.2.1.patch` already includes these required entries for PRODUCT_PACKAGES in the file ./build/target/product/core.mk

Update the API:
{{{
$ make update-api
}}}

Continue with the instructions as described in section "Building the system".

<br><br> 
=Using the !SmartCard API via shared library =

An application can use the !SmartCard API via a shared library ("org.simalliance.openmobileapi" or "android.smartcard") by defining the shared library name in its !AndroidManfest.xml in a  [http://developer.android.com/guide/topics/manifest/uses-library-element.html uses-library-element]. This element tells the android system where the library classes (used by the application) can be found in the system.

The "uses-library" allows to set an android:required flag:
 * <b>android:required="true"</b> <br>
 indicates if the application (which uses the shared library) can only be installed to the device if the library is available in the device. This option is useful if the application absolutely needs the library for the execution. Consider that the application (which requires the shard library) is not visible in the Android Market if the shared library is not available on the device.
 * <b>android:required="false"</b> <br>
 indicates if the application (which uses the shared library) can be installed to the device even if the library is not available in the device. This option is useful if the application can use the library for performing an action but does not require it for the general execution.

Example of an `AndroidManfest.xml` of an application which uses the SIMalliance standardized interface OpenMobileAPI:

{{{
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          ...
        <activity android:name="<ActivityName>"
	<uses-library android:name="org.simalliance.openmobileapi" android:required="true" />
        </activity>
        ...
</manifest> 
}}}

Example of an `AndroidManfest.xml` of an application which uses the proprietary interface !SmartcardClient:

{{{
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          ...
        <activity android:name="<ActivityName>"
	<uses-library android:name="android.smartcard" android:required="true" />
        </activity>
        ...
</manifest> 
}}}

For compiling the application (using the shard library based !SmartCard API) the shared library classes has to be explicitly added to the classpath as these classes are not part of the android  SDK framework. Therefore add the JAR archive (besides the Android SDK JAR archive "android.jar") of the needed shared library ("org.simalliance.openmobileapi" or "android.smartcard") to your classpath.
<br/><br/>
After an Android system build (containing the shared library based !SmartCard API) the JAR archive of the "org.simalliance.openmobileapi" shared library can be found here:
{{{
<ANDROID_ROOT_DIR>/out/target/common/obj/JAVA_LIBRARIES/org.simalliance.openmobileapi_intermediates/classes-full-debug.jar
}}}
After an Android system build (containing the shared library based !SmartCard API) the JAR archive of the "android.smartcard" shared library can be found here:
{{{
<ANDROID_ROOT_DIR>/out/target/common/obj/JAVA_LIBRARIES/android.smartcardapi_intermediates/classes-full-debug.jar
}}}
