#summary Enable Android to run in an LXC container

= Introduction =

This document describes how to setup and run multiple isolated Android user-space instances on a commercial mobile device like Nexus One. Operating system-level virtualization method Linux Containers (LXC) is applied to create and run Android Containers on a single control host. The standard Android Kernel is modified to boot GNU-Linux from SD-card and to provide isolation mechanisms and resource management features for Android user-space. 

<br>
= 1 Requirements =
  * Nexus One
  * SD-card (> 2GB recommended)
  * x86-Linux environment
  * Sun Java 6 JDK, JRE
  * Version Control tools Repo and Git ([http://source.android.com/source/downloading.html download])

<br>
= 2 Building and flashing the kernel =

In this section we describe how to modify the stock Nexus One firmware (mainly boot.img) to be able to boot a GNU-Linux directly from SD-card. This method enables us to run a plain GNU-Linux environment natively (no chroot!) on the device hardware. Additionally kernel configuration options and source code are patched to provide LXC container virtualization environment. Finally we describe how the modified kernel is properly packaged into a boot.img and flashed on the Nexus One device.

<br>
== 2.1 Download Android source and setup build environment ==

In order to compile the kernel from scratch a toolchain for cross-compiling is needed. Please follow instructions from Google [http://http://source.android.com/source/initializing.html here] for setting up a Linux or MacOSX build environment and [http://source.android.com/source/downloading.html here] for getting the Android SDK which contains a pre-built toolchain. The Android source directory is from now on indicated as ANDROID_DIR.

<br>
== 2.2 Download and patch kernel sources ==

The kernel sources for Nexus One can be downloaded through the command:
{{{
$ git clone https://android.googlesource.com/kernel/msm.git
The repository is created in the subfolder msm
$ cd <MSM_DIR>
}}}

Note: Currently we can only provide a patch for 2.6.35.7 kernel.

Download the [http://seek-for-android.googlecode.com/files/sdcard-lxc-kernel.tar.gz sdcard-lxc-kernel.tar.gz] patch and extract the content:

 * sdcard-lxc-kernel.patch - patches kernel for SD-card boot and LXC support
 * readme.txt - description how to build

Apply the patch:

{{{
<MSM_DIR>$ patch -p1 < sdcard-lxc-kernel.patch
}}}

<br>
== 2.3 Compile and flash the kernel ==

Now we are ready to build the kernel:

{{{
<MSM_DIR>$ make ARCH=arm CROSS_COMPILE=<ANDROID_DIR>/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi- -j4
}}}

Note: In case the new kernel has not the correct kernel revision number or a -dirty flag is appended, you have to create a .scmversion file inside the kernel directory with a proper revision number and build the kernel again:
{{{
<MSM_DIR>$ echo '-g3cc95e3' > .scmversion
<MSM_DIR>$ make ARCH=arm CROSS_COMPILE=<ANDROID_DIR>/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi- -j4
}}}

The newly created kernel MSM_DIR/arch/arm/boot/zImage needs to be packaged into a boot.img before it can be flashed onto device. In order to create and flash the boot.img we need to compile the necessary tools first:

{{{
$ cd <ANDROID_DIR>
<ANDROID_DIR>$ . build/envsetup.sh
<ANDROID_DIR>$ lunch full_passion-eng
<ANDROID_DIR>$ make -j4
}}}

After a successfull build tools like mkbootimg, fastboot and adb are available in the ANDROID_DIR/out/host/linux-x86/bin directory. We add it to the PATH variable:

{{{
$ export PATH=<ANDROID_DIR>/out/host/linux-x86/bin:$PATH
}}}

The goal of the next step is to package the newly created kernel zImage and the unmodified ramdisk.img into a new boot.img. Since we don't want to boot from the ramdisk but directly from the SD-card, the kernel cmdline needs to be modified permanently. The kernel replacement and cmdline modification is achieved by this command:

{{{
$ mkbootimg \ 
--kernel <MSM_DIR>/arch/arm/boot/zImage \
--ramdisk <ANDROID_DIR>/out/target/product/passion/ramdisk.img \
--cmdline "no_console_suspend=1 wire.search_count=5 root=/dev/mmcblk0p2 rw rootfs=ext2 init=/sbin/init rootwait noinitrd" \
--base 0x20000000 \
--output <ANDROID_DIR>/out/target/product/passion/boot.img
}}}

Note: For future target devices the correct mkbootimg parameters can be easily determined by recompiling the boot.img with the showcommands option: 
{{{
<ANDROID_DIR>$ make bootimage showcommands
}}}

Note: If you don't want to build your own image a fully working boot.img can be downloaded [http://seek-for-android.googlecode.com/files/sdcard-lxc-boot.img here]

Now we can flash the new boot.img onto the boot partition. The device has to be rooted and the USB permissions have to be setup properly. In case of any problems check [https://www.google.com/search?q=root+nexus+one here] and  [http://source.android.com/source/initializing.html here (section: Configuring USB Access)].

{{{
$ adb reboot bootloader
$ fastboot flash boot <ANDROID_DIR>/out/target/product/passion/boot.img
}}}

Note: Once you replaced the boot.img with modified cmdline to boot from SD-card, you can easily update the kernel zImage on the device without the need to create a boot.img again:

{{{
$ fastboot flash zimage <MSM_DIR>/arch/arm/boot/zImage
}}}

Since we don't touch the original system and userdata partitions, the original boot.img can be flashed to recovery partition to provide a convenient way to boot 'the normal way' from the bootloader menu. 

In the next step we prepare the GNU-linux environment on the SD-card and configure LXC tools for the Android Container.

<br>
= 3 Host System Setup =

For our virtualization solution with Linux Containers (LXC) a standard GNU-linux, in this case Debian (squeeze) distribution is configured to run as host system directly from SD-card on the mobile device. This setup has several advantages, mainly a convenient way of installing new software packages currently available in the Debian repositories for the armel architecture and further avoiding possible space restrictions of the built-in device flash memory. 

<br>
== 3.1 Preparing the SD-card ==

The following steps have to be performed on any external linux-system with SD-card slot.

  * Create two partitions on the SD-card, a small vfat partition as first partition to simulate the standard SD-card and a second bigger ext2 partition (>2GB) where we place our host system and the Android containers (ext3 & ext4 is not recommended due to journaling capabilities which reduce the lifetime of SD-card). 
  * Mount the ext2 partition on the linux-system to any directory MNT_DIR and debootstrap a minimal Debian (sqeeze) for the armel architecture:

{{{
$ sudo mount /dev/mmcblk0p2 <MNT_DIR>
$ debootstrap --foreign --arch=armel --variant=minbase \ 
squeeze <MNT_DIR> http://ftp.debian.org/debian
}}}

For the second step of debootstrapping the system we need to access the debian ext2 partition from the mobile device. In this step all the necessary device nodes etc. are created, thus this task has to be performed in our target system environment, i.e. in the adb shell after a regular boot:

{{{
$ adb shell
# mount -t ext2 /dev/block/mmcblk0p2 <MNT_DIR>
# chroot <MNT_DIR> /debootstrap/debootstrap --second-stage
}}}

Note: mount/chroot can be executed with help of a busybox which can be downloaded [http://busybox.net/downloads/binaries/1.19.0/ here]. How to use busybox on an Android device is explained for example [http://www.saurik.com/id/10 here].

  
<br>
== 3.2 Configuring the Host System ==

After a basic Debian system on the ext2 partition of the SD-card is created, several configuration changes have to be made in order to be able to directly boot it on the device. First minimum required settings are presented to perform the very first successful boot and then additional features are configured like networking, sound, X11, etc.

Since there is usually no serial cable available (example how to build a serial cable can be found [http://trac.osuosl.org/trac/replicant/wiki/NexusSBootloader here]) we have to ensure that the linux environment boots up without errors and the adb daemon is started at system startup. Thus the connection to the the Debian host root shell can be established through adb. 

But first we need to boot the device normally and execute these commands:
{{{
$ adb shell

# mount -t ext2 /dev/block/mmcblk0p2 <MNT_DIR>
# cp /sbin/adbd <MNT_DIR>/sbin/adbd
# cat > <MNT_DIR>/etc/rc.local << EOF
> /sbin/adbd &
> exit 0
> EOF

# mkdir -p <MNT_DIR>/system/bin/
# ln -s /bin/bash <MNT_DIR>/system/bin/sh

# cat > <MNT_DIR>/etc/fstab << EOF 
> /dev/block/mmcblk0p2 / ext2 defaults 1 0
> proc /proc proc defaults 0 0
> EOF
}}}

Now the Debian host system is ready for the first native boot! Test the connection via adb and if that works reboot the device normally to perform further configuration steps. Otherwise check previous steps for errors. 

Next we need to install some packages from the repository, e.g. wpasupplicant for networking support. Since we need obviously internet connection to do this, we have to boot Android normally and establish an internet connection by its means. Then we chroot into Debian to install the necessary packages:

{{{
$ adb shell
# mount -t ext2 /dev/block/mmcblk0p2 <MNT_DIR>
# chroot <MNT_DIR> /bin/bash
$ export PATH=/usr/bin:/usr/sbin:/bin:$PATH
$ export TERM=linux
$ echo 'deb http://ftp.debian.org/debian squeeze main' > /etc/apt/sources.list
$ apt-get update
$ apt-get install wpasupplicant wireless-tools
$ apt-get install locales vi
$ exit
}}}

In order to setup networking for the Debian host system, first we have to copy the wifi kernel module and the firmware and then we have to configure wpasupplicant to be able to establish wifi connections from within the Debian environment. These commands should be executed inside the adb shell (not chroot!):

{{{
$ mkdir -p <MNT_DIR>/lib/modules/`uname -r`/drivers/net/wireless/
$ cp /system/lib/modules/bcm4329.ko \
  <MNT_DIR>/lib/modules/`uname -r`/drivers/net/wireless/
$ mkdir -p <MNT_DIR>/system/vendor/firmware/
$ cp /system/vendor/firmware/fw_bcm4329.bin \
  <MNT_DIR>/system/vendor/firmware/
$ echo 'bcm4329' > <MNT_DIR>/etc/modules

$ cat > <MNT_DIR>/etc/network/interfaces << EOF 
< auto lo
< iface lo inet loopback
<
< auto eth0
< iface eth0 inet manual
<   wpa-driver wext
<
< wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf
<
< iface your_wlan_name inet dhcp
< EOF

$ cat > <MNT_DIR>/etc/wpa_supplicant/wpa_supplicant.conf << EOF
< ctrl_interface=/var/run/wpa_supplicant
< ap_scan=2
< fast_reauth=1
< network={
<         ssid="your_wlan_ssid"
<         id_str="your_wlan_name"
<         scan_ssid=1
<         mode=0
<         proto=WPA
<         key_mgmt=WPA-PSK
<         pairwise=CCMP TKIP
<         group=TKIP
<         psk="your_wlan_password"
< }
< EOF

}}}

Now we should have a fully functional networking inside the Debian host system. 

TODO: setup description of X11, sound, etc.

<br>
== 3.3 Setup LXC userspace tools ==
TEXT: control group file system, bridge setup, etc...

<br>
= 4 Android Container Setup =
<br>
== 4.1 Container Configuration File ==
<br>
== 4.2 Device Nodes ==
<br>
== 4.3 Android modifications ==
TEXT: init.rc, init, DalvikVM, system_server, Networking, bridging, busybox (route), etc...

<br>
= 5 Notes =
TEXT: fsck.ext2, button trigger, ...

<br>
= Todo =
TEXT: sdcard emulation, lxc-console, parallel fb access, secureSD


<br>
= References =
[http://en.wikipedia.org/wiki/Operating_system-level_virtualization] <br>
[http://lxc.sourceforge.net/]<br>
[http://lxc.teegra.net/]<br>
[http://www.irregular-expression.com/?p=30]<br>



<br>
= Useful Resources =
[http://source.android.com/source/downloading.html]<br>

<br>
<br>
<br>
<br>